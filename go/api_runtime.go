/*
Tenant API

Tenant API

API version: 0.0.1
Contact: abc@layer.fr
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package graalsystems

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RuntimeAPIService RuntimeAPI service
type RuntimeAPIService service

type ApiBuildRuntimeByIdRequest struct {
	ctx context.Context
	ApiService *RuntimeAPIService
	xTenant *string
	runtimeId string
}

func (r ApiBuildRuntimeByIdRequest) XTenant(xTenant string) ApiBuildRuntimeByIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiBuildRuntimeByIdRequest) Execute() (*Build, *http.Response, error) {
	return r.ApiService.BuildRuntimeByIdExecute(r)
}

/*
BuildRuntimeById Find runtime by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runtimeId Id of the runtime
 @return ApiBuildRuntimeByIdRequest
*/
func (a *RuntimeAPIService) BuildRuntimeById(ctx context.Context, runtimeId string) ApiBuildRuntimeByIdRequest {
	return ApiBuildRuntimeByIdRequest{
		ApiService: a,
		ctx: ctx,
		runtimeId: runtimeId,
	}
}

// Execute executes the request
//  @return Build
func (a *RuntimeAPIService) BuildRuntimeByIdExecute(r ApiBuildRuntimeByIdRequest) (*Build, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Build
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuntimeAPIService.BuildRuntimeById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtimes/{runtimeId}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"runtimeId"+"}", url.PathEscape(parameterValueToString(r.runtimeId, "runtimeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xTenant == nil {
		return localVarReturnValue, nil, reportError("xTenant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.graal.systems.v1.build+json", "application/vnd.graal.systems.v1.error+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRuntimeRequest struct {
	ctx context.Context
	ApiService *RuntimeAPIService
	xTenant *string
	runtime *Runtime
}

func (r ApiCreateRuntimeRequest) XTenant(xTenant string) ApiCreateRuntimeRequest {
	r.xTenant = &xTenant
	return r
}

// The runtime to be created
func (r ApiCreateRuntimeRequest) Runtime(runtime Runtime) ApiCreateRuntimeRequest {
	r.runtime = &runtime
	return r
}

func (r ApiCreateRuntimeRequest) Execute() (*Runtime, *http.Response, error) {
	return r.ApiService.CreateRuntimeExecute(r)
}

/*
CreateRuntime Create runtime

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRuntimeRequest
*/
func (a *RuntimeAPIService) CreateRuntime(ctx context.Context) ApiCreateRuntimeRequest {
	return ApiCreateRuntimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Runtime
func (a *RuntimeAPIService) CreateRuntimeExecute(r ApiCreateRuntimeRequest) (*Runtime, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Runtime
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuntimeAPIService.CreateRuntime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtimes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xTenant == nil {
		return localVarReturnValue, nil, reportError("xTenant is required and must be specified")
	}
	if r.runtime == nil {
		return localVarReturnValue, nil, reportError("runtime is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.graal.systems.v1.runtime+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.graal.systems.v1.runtime+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "")
	// body params
	localVarPostBody = r.runtime
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRuntimeByIdRequest struct {
	ctx context.Context
	ApiService *RuntimeAPIService
	xTenant *string
	runtimeId string
}

func (r ApiDeleteRuntimeByIdRequest) XTenant(xTenant string) ApiDeleteRuntimeByIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiDeleteRuntimeByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRuntimeByIdExecute(r)
}

/*
DeleteRuntimeById Delete a runtime by an id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runtimeId Id of the runtime
 @return ApiDeleteRuntimeByIdRequest
*/
func (a *RuntimeAPIService) DeleteRuntimeById(ctx context.Context, runtimeId string) ApiDeleteRuntimeByIdRequest {
	return ApiDeleteRuntimeByIdRequest{
		ApiService: a,
		ctx: ctx,
		runtimeId: runtimeId,
	}
}

// Execute executes the request
func (a *RuntimeAPIService) DeleteRuntimeByIdExecute(r ApiDeleteRuntimeByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuntimeAPIService.DeleteRuntimeById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtimes/{runtimeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"runtimeId"+"}", url.PathEscape(parameterValueToString(r.runtimeId, "runtimeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xTenant == nil {
		return nil, reportError("xTenant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.graal.systems.v1.error+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindBuildByRuntimeIdAndBuildIdRequest struct {
	ctx context.Context
	ApiService *RuntimeAPIService
	xTenant *string
	runtimeId string
	buildId string
}

func (r ApiFindBuildByRuntimeIdAndBuildIdRequest) XTenant(xTenant string) ApiFindBuildByRuntimeIdAndBuildIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiFindBuildByRuntimeIdAndBuildIdRequest) Execute() (*Build, *http.Response, error) {
	return r.ApiService.FindBuildByRuntimeIdAndBuildIdExecute(r)
}

/*
FindBuildByRuntimeIdAndBuildId Find the build by a runtimeId and a buildId

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runtimeId Id of the runtime
 @param buildId Id of the build
 @return ApiFindBuildByRuntimeIdAndBuildIdRequest
*/
func (a *RuntimeAPIService) FindBuildByRuntimeIdAndBuildId(ctx context.Context, runtimeId string, buildId string) ApiFindBuildByRuntimeIdAndBuildIdRequest {
	return ApiFindBuildByRuntimeIdAndBuildIdRequest{
		ApiService: a,
		ctx: ctx,
		runtimeId: runtimeId,
		buildId: buildId,
	}
}

// Execute executes the request
//  @return Build
func (a *RuntimeAPIService) FindBuildByRuntimeIdAndBuildIdExecute(r ApiFindBuildByRuntimeIdAndBuildIdRequest) (*Build, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Build
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuntimeAPIService.FindBuildByRuntimeIdAndBuildId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtimes/{runtimeId}/builds/{buildId}"
	localVarPath = strings.Replace(localVarPath, "{"+"runtimeId"+"}", url.PathEscape(parameterValueToString(r.runtimeId, "runtimeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"buildId"+"}", url.PathEscape(parameterValueToString(r.buildId, "buildId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xTenant == nil {
		return localVarReturnValue, nil, reportError("xTenant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.graal.systems.v1.build+json", "application/vnd.graal.systems.v1.error+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindBuildsForRuntimeRequest struct {
	ctx context.Context
	ApiService *RuntimeAPIService
	xTenant *string
	runtimeId string
}

func (r ApiFindBuildsForRuntimeRequest) XTenant(xTenant string) ApiFindBuildsForRuntimeRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiFindBuildsForRuntimeRequest) Execute() ([]Build, *http.Response, error) {
	return r.ApiService.FindBuildsForRuntimeExecute(r)
}

/*
FindBuildsForRuntime Retrieve all builds for a runtime

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runtimeId Id of the runtime
 @return ApiFindBuildsForRuntimeRequest
*/
func (a *RuntimeAPIService) FindBuildsForRuntime(ctx context.Context, runtimeId string) ApiFindBuildsForRuntimeRequest {
	return ApiFindBuildsForRuntimeRequest{
		ApiService: a,
		ctx: ctx,
		runtimeId: runtimeId,
	}
}

// Execute executes the request
//  @return []Build
func (a *RuntimeAPIService) FindBuildsForRuntimeExecute(r ApiFindBuildsForRuntimeRequest) ([]Build, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Build
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuntimeAPIService.FindBuildsForRuntime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtimes/{runtimeId}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"runtimeId"+"}", url.PathEscape(parameterValueToString(r.runtimeId, "runtimeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xTenant == nil {
		return localVarReturnValue, nil, reportError("xTenant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.graal.systems.v1.build+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindDependenciesByRuntimeIdAndVersionIdRequest struct {
	ctx context.Context
	ApiService *RuntimeAPIService
	xTenant *string
	runtimeId string
	versionId string
}

func (r ApiFindDependenciesByRuntimeIdAndVersionIdRequest) XTenant(xTenant string) ApiFindDependenciesByRuntimeIdAndVersionIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiFindDependenciesByRuntimeIdAndVersionIdRequest) Execute() ([]Dependency, *http.Response, error) {
	return r.ApiService.FindDependenciesByRuntimeIdAndVersionIdExecute(r)
}

/*
FindDependenciesByRuntimeIdAndVersionId Find the dependencies by a runtimeId and a versionId

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runtimeId Id of the runtime
 @param versionId Id of the version
 @return ApiFindDependenciesByRuntimeIdAndVersionIdRequest
*/
func (a *RuntimeAPIService) FindDependenciesByRuntimeIdAndVersionId(ctx context.Context, runtimeId string, versionId string) ApiFindDependenciesByRuntimeIdAndVersionIdRequest {
	return ApiFindDependenciesByRuntimeIdAndVersionIdRequest{
		ApiService: a,
		ctx: ctx,
		runtimeId: runtimeId,
		versionId: versionId,
	}
}

// Execute executes the request
//  @return []Dependency
func (a *RuntimeAPIService) FindDependenciesByRuntimeIdAndVersionIdExecute(r ApiFindDependenciesByRuntimeIdAndVersionIdRequest) ([]Dependency, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Dependency
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuntimeAPIService.FindDependenciesByRuntimeIdAndVersionId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtimes/{runtimeId}/versions/{versionId}/dependencies"
	localVarPath = strings.Replace(localVarPath, "{"+"runtimeId"+"}", url.PathEscape(parameterValueToString(r.runtimeId, "runtimeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionId"+"}", url.PathEscape(parameterValueToString(r.versionId, "versionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xTenant == nil {
		return localVarReturnValue, nil, reportError("xTenant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.graal.systems.v1.dependency+json", "application/vnd.graal.systems.v1.error+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindRuntimeByIdRequest struct {
	ctx context.Context
	ApiService *RuntimeAPIService
	xTenant *string
	runtimeId string
}

func (r ApiFindRuntimeByIdRequest) XTenant(xTenant string) ApiFindRuntimeByIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiFindRuntimeByIdRequest) Execute() (*Runtime, *http.Response, error) {
	return r.ApiService.FindRuntimeByIdExecute(r)
}

/*
FindRuntimeById Find runtime by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runtimeId Id of the runtime
 @return ApiFindRuntimeByIdRequest
*/
func (a *RuntimeAPIService) FindRuntimeById(ctx context.Context, runtimeId string) ApiFindRuntimeByIdRequest {
	return ApiFindRuntimeByIdRequest{
		ApiService: a,
		ctx: ctx,
		runtimeId: runtimeId,
	}
}

// Execute executes the request
//  @return Runtime
func (a *RuntimeAPIService) FindRuntimeByIdExecute(r ApiFindRuntimeByIdRequest) (*Runtime, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Runtime
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuntimeAPIService.FindRuntimeById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtimes/{runtimeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"runtimeId"+"}", url.PathEscape(parameterValueToString(r.runtimeId, "runtimeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xTenant == nil {
		return localVarReturnValue, nil, reportError("xTenant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.graal.systems.v1.runtime+json", "application/vnd.graal.systems.v1.error+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindRuntimesRequest struct {
	ctx context.Context
	ApiService *RuntimeAPIService
	xTenant *string
}

func (r ApiFindRuntimesRequest) XTenant(xTenant string) ApiFindRuntimesRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiFindRuntimesRequest) Execute() ([]Runtime, *http.Response, error) {
	return r.ApiService.FindRuntimesExecute(r)
}

/*
FindRuntimes Retrieve all runtimes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindRuntimesRequest
*/
func (a *RuntimeAPIService) FindRuntimes(ctx context.Context) ApiFindRuntimesRequest {
	return ApiFindRuntimesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Runtime
func (a *RuntimeAPIService) FindRuntimesExecute(r ApiFindRuntimesRequest) ([]Runtime, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Runtime
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuntimeAPIService.FindRuntimes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtimes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xTenant == nil {
		return localVarReturnValue, nil, reportError("xTenant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.graal.systems.v1.runtime+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindVersionByRuntimeIdAndVersionIdRequest struct {
	ctx context.Context
	ApiService *RuntimeAPIService
	xTenant *string
	runtimeId string
	versionId string
}

func (r ApiFindVersionByRuntimeIdAndVersionIdRequest) XTenant(xTenant string) ApiFindVersionByRuntimeIdAndVersionIdRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiFindVersionByRuntimeIdAndVersionIdRequest) Execute() (*RuntimeVersion, *http.Response, error) {
	return r.ApiService.FindVersionByRuntimeIdAndVersionIdExecute(r)
}

/*
FindVersionByRuntimeIdAndVersionId Find the build by a runtimeId and a versionId

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runtimeId Id of the runtime
 @param versionId Id of the version
 @return ApiFindVersionByRuntimeIdAndVersionIdRequest
*/
func (a *RuntimeAPIService) FindVersionByRuntimeIdAndVersionId(ctx context.Context, runtimeId string, versionId string) ApiFindVersionByRuntimeIdAndVersionIdRequest {
	return ApiFindVersionByRuntimeIdAndVersionIdRequest{
		ApiService: a,
		ctx: ctx,
		runtimeId: runtimeId,
		versionId: versionId,
	}
}

// Execute executes the request
//  @return RuntimeVersion
func (a *RuntimeAPIService) FindVersionByRuntimeIdAndVersionIdExecute(r ApiFindVersionByRuntimeIdAndVersionIdRequest) (*RuntimeVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RuntimeVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuntimeAPIService.FindVersionByRuntimeIdAndVersionId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtimes/{runtimeId}/versions/{versionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"runtimeId"+"}", url.PathEscape(parameterValueToString(r.runtimeId, "runtimeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionId"+"}", url.PathEscape(parameterValueToString(r.versionId, "versionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xTenant == nil {
		return localVarReturnValue, nil, reportError("xTenant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.graal.systems.v1.runtimeversion+json", "application/vnd.graal.systems.v1.error+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindVersionsForRuntimeRequest struct {
	ctx context.Context
	ApiService *RuntimeAPIService
	xTenant *string
	runtimeId string
}

func (r ApiFindVersionsForRuntimeRequest) XTenant(xTenant string) ApiFindVersionsForRuntimeRequest {
	r.xTenant = &xTenant
	return r
}

func (r ApiFindVersionsForRuntimeRequest) Execute() ([]RuntimeVersion, *http.Response, error) {
	return r.ApiService.FindVersionsForRuntimeExecute(r)
}

/*
FindVersionsForRuntime Retrieve all versions for a runtime

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runtimeId Id of the runtime
 @return ApiFindVersionsForRuntimeRequest
*/
func (a *RuntimeAPIService) FindVersionsForRuntime(ctx context.Context, runtimeId string) ApiFindVersionsForRuntimeRequest {
	return ApiFindVersionsForRuntimeRequest{
		ApiService: a,
		ctx: ctx,
		runtimeId: runtimeId,
	}
}

// Execute executes the request
//  @return []RuntimeVersion
func (a *RuntimeAPIService) FindVersionsForRuntimeExecute(r ApiFindVersionsForRuntimeRequest) ([]RuntimeVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RuntimeVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuntimeAPIService.FindVersionsForRuntime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtimes/{runtimeId}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"runtimeId"+"}", url.PathEscape(parameterValueToString(r.runtimeId, "runtimeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xTenant == nil {
		return localVarReturnValue, nil, reportError("xTenant is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.graal.systems.v1.runtimeversion+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLogsForBuildRequest struct {
	ctx context.Context
	ApiService *RuntimeAPIService
	xTenant *string
	runtimeId string
	buildId string
	cursor *string
}

func (r ApiGetLogsForBuildRequest) XTenant(xTenant string) ApiGetLogsForBuildRequest {
	r.xTenant = &xTenant
	return r
}

// The cursor
func (r ApiGetLogsForBuildRequest) Cursor(cursor string) ApiGetLogsForBuildRequest {
	r.cursor = &cursor
	return r
}

func (r ApiGetLogsForBuildRequest) Execute() ([]LogEntry, *http.Response, error) {
	return r.ApiService.GetLogsForBuildExecute(r)
}

/*
GetLogsForBuild Get logs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runtimeId Id of the runtime
 @param buildId Id of the build
 @return ApiGetLogsForBuildRequest
*/
func (a *RuntimeAPIService) GetLogsForBuild(ctx context.Context, runtimeId string, buildId string) ApiGetLogsForBuildRequest {
	return ApiGetLogsForBuildRequest{
		ApiService: a,
		ctx: ctx,
		runtimeId: runtimeId,
		buildId: buildId,
	}
}

// Execute executes the request
//  @return []LogEntry
func (a *RuntimeAPIService) GetLogsForBuildExecute(r ApiGetLogsForBuildRequest) ([]LogEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LogEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RuntimeAPIService.GetLogsForBuild")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/runtimes/{runtimeId}/builds/{buildId}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"runtimeId"+"}", url.PathEscape(parameterValueToString(r.runtimeId, "runtimeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"buildId"+"}", url.PathEscape(parameterValueToString(r.buildId, "buildId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xTenant == nil {
		return localVarReturnValue, nil, reportError("xTenant is required and must be specified")
	}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.graal.systems.v1.log+json", "application/vnd.graal.systems.v1.error+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Tenant", r.xTenant, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
